/*
 *
题目大意：
有一个天平，天平左右两边各有若干个钩子，总共有C个钩子，有G个钩码，求将钩码全部挂到钩子上使天平平衡的方法的总数。
其中可以把天枰看做一个以x轴0点作为平衡点的横轴
输入：
2 4 //C 钩子数 与 G钩码数
-2 3 //负数：左边的钩子距离天平中央的距离；正数：右边的钩子距离天平中央的距离c[k]
3 4 5 8 //G个重物的质量w[i]

状态数组dp[i][j]，意为在挂满前i个钩码时，平衡度为j的挂法的数量
平衡度最大值为j=15*20*25=7500

因此为了不让下标出现负数，做一个处理，使使得数组开为 dp[1~20][0~15000]，则当j=7500时天枰为平衡状态

不难想到，假设 dp[i-1][j] 的值已知，设dp[i-1][j]=num
               （即已知把前i-1个钩码全部挂上天枰后得到状态j的方法有num次）
   那么dp[i][ j+ w[i]*c[k] ] = dp[i-1][j] = num
(即以此为前提，在第k个钩子挂上第i个钩码后，得到状态j+ w[i]*c[k]的方法也为num次)

想到这里，利用递归思想，不难得出 状态方程dp[i][ j+ w[i]*c[k] ]= ∑（dp[i-1][j]）

结论：
最终转化为01背包问题
状态方程dp[i][ j+ w[i]*c[k] ]= ∑（dp[i-1][j]）
初始化：dp[0][7500] = 1;   //不挂任何重物时天枰平衡，此为一个方法
 *
 *
 */

#include <iostream> 
#include <string.h>
using namespace std;  
  
int dp[21][15001]; //状态数组dp[i][j]  
                       //放入（挂上）前i个物品（钩码）后，达到j状态的方法数  
int main(int i,int j,int k)  
{  
    int n;  //挂钩数  
    int g;  //钩码数  
    int c[21];  //挂钩位置  
    int w[21];  //钩码重量  
  
      
    /*Input*/  
  
    cin>>n>>g;  
  
    for(i=1;i<=n;i++)  
        cin>>c[i];  
    for(i=1;i<=g;i++)  
        cin>>w[i];  
  
    /*Initial*/  
  
    memset(dp,0,sizeof(dp));  //达到每个状态的方法数初始化为0  
    dp[0][7500]=1;     //7500为天枰达到平衡状态时的平衡度  
                       //放入前0个物品后，天枰达到平衡状态7500的方法有1个，就是不挂钩码  
  
    /*DP*/  
  
    for(i=1;i<=g;i++)  
        for(j=0;j<=15000;j++)  
            //if(dp[i-1][j])  //优化，当放入i-1个物品时状态j已经出现且被统计过方法数，则直接使用统计结果  
                            //否则忽略当前状态j  
                for(k=1;k<=n;k++)  
                    dp[i][ j+w[i]*c[k] ] += dp[i-1][j]; //状态方程  
      
    /*Output*/  
  
    cout<<dp[g][7500]<<endl;  
    return 0;  
}
